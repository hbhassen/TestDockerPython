üéØ Objectif final (clair)

Pour un User :

companies ‚Üí List<String>

roles ‚Üí List<String>

addresses (OneToMany) ‚Üí List<String> ou List<AddressView>

orders (OneToMany) ‚Üí List<Long> ou List<OrderView>

üëâ Tout dans une VIEW PostgreSQL classique
üëâ 1 ligne = 1 user
üëâ Aucun COUNT

üß† R√®gle d‚Äôor (√† retenir)

‚ùó Une collection (OneToMany, ManyToMany) DOIT √™tre agr√©g√©e dans une VIEW
üëâ sinon tu casses la cardinalit√© (duplication de lignes)

üëâ La seule bonne solution = JSON_AGG

1Ô∏è‚É£ VIEW PostgreSQL ‚Äì LISTES pour OneToMany
Exemple : addresses et orders en LISTE
Hypoth√®se m√©tier

user_address : plusieurs adresses par user

user_order : plusieurs commandes par user

‚úÖ SQL COMPLET (OneToMany = LISTE)
CREATE VIEW v_user_account_full AS
SELECT
    u.id                                   AS id,
    u.username                             AS username,
    u.email                                AS email,

    -- OneToOne
    p.first_name                           AS first_name,
    p.last_name                            AS last_name,

    -- OneToMany ‚Üí LISTE
    JSON_AGG(DISTINCT a.street)
        FILTER (WHERE a.id IS NOT NULL)    AS addresses,

    JSON_AGG(DISTINCT o.order_number)
        FILTER (WHERE o.id IS NOT NULL)    AS orders,

    -- ManyToMany ‚Üí LISTE
    JSON_AGG(DISTINCT c.name)
        FILTER (WHERE c.id IS NOT NULL)    AS companies,

    JSON_AGG(DISTINCT r.name)
        FILTER (WHERE r.id IS NOT NULL)    AS roles

FROM user_account u

LEFT JOIN user_profile p
       ON p.user_id = u.id

LEFT JOIN user_address a
       ON a.user_id = u.id

LEFT JOIN user_order o
       ON o.user_id = u.id

LEFT JOIN user_company uc
       ON uc.user_id = u.id

LEFT JOIN company c
       ON c.id = uc.company_id

LEFT JOIN user_role ur
       ON ur.user_id = u.id

LEFT JOIN role r
       ON r.id = ur.role_id

GROUP BY
    u.id,
    u.username,
    u.email,
    p.first_name,
    p.last_name;

üîé R√©sultat r√©el SQL
{
  "addresses": [
    "12 rue Victor Hugo",
    "5 avenue de Paris"
  ],
  "orders": [
    "ORD-2024-001",
    "ORD-2024-002"
  ],
  "companies": ["ACME", "BNP"],
  "roles": ["ADMIN", "USER"]
}

2Ô∏è‚É£ Liquibase YAML ‚Äì VIEW
databaseChangeLog:
  - changeSet:
      id: 001-create-v-user-account-full
      author: hamdi
      changes:
        - createView:
            viewName: v_user_account_full
            replaceIfExists: true
            selectQuery: |
              SELECT
                  u.id                                   AS id,
                  u.username                             AS username,
                  u.email                                AS email,
                  p.first_name                           AS first_name,
                  p.last_name                            AS last_name,
                  JSON_AGG(DISTINCT a.street)
                      FILTER (WHERE a.id IS NOT NULL)    AS addresses,
                  JSON_AGG(DISTINCT o.order_number)
                      FILTER (WHERE o.id IS NOT NULL)    AS orders,
                  JSON_AGG(DISTINCT c.name)
                      FILTER (WHERE c.id IS NOT NULL)    AS companies,
                  JSON_AGG(DISTINCT r.name)
                      FILTER (WHERE r.id IS NOT NULL)    AS roles
              FROM user_account u
              LEFT JOIN user_profile p ON p.user_id = u.id
              LEFT JOIN user_address a ON a.user_id = u.id
              LEFT JOIN user_order o ON o.user_id = u.id
              LEFT JOIN user_company uc ON uc.user_id = u.id
              LEFT JOIN company c ON c.id = uc.company_id
              LEFT JOIN user_role ur ON ur.user_id = u.id
              LEFT JOIN role r ON r.id = ur.role_id
              GROUP BY
                  u.id,
                  u.username,
                  u.email,
                  p.first_name,
                  p.last_name

3Ô∏è‚É£ Mapping JPA ‚Äì LISTES (Hibernate 6)
‚úÖ Cas 1 : List<String> (simple, recommand√©)
@Entity
@Table(name = "v_user_account_full")
@Immutable
public class UserAccountView {

    @Id
    private Long id;

    private String username;
    private String email;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private List<String> addresses;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private List<String> orders;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private List<String> companies;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private List<String> roles;
}

‚úÖ Cas 2 : List<AddressView> (objet structur√©)
SQL
JSON_AGG(
  DISTINCT jsonb_build_object(
    'street', a.street,
    'city', a.city
  )
) FILTER (WHERE a.id IS NOT NULL) AS addresses

Java
public record AddressView(String street, String city) {}

@JdbcTypeCode(SqlTypes.JSON)
@Column(columnDefinition = "jsonb")
private List<AddressView> addresses;


‚úî Hibernate 6 le supporte nativement

4Ô∏è‚É£ Ce qu‚Äôil NE FAUT PAS faire

‚ùå COUNT(a.id) (tu l‚Äôas explicitement refus√©)
‚ùå @OneToMany dans la VIEW
‚ùå plusieurs lignes par user
‚ùå parsing JSON manuel

5Ô∏è‚É£ Repository (inchang√©)
@Repository
public interface UserAccountViewRepository
        extends JpaRepository<UserAccountView, Long> {
}

üß™ Test SQL obligatoire
SELECT addresses, orders
FROM v_user_account_full
WHERE id = 1;

‚úÖ Exigences minimales

JDK : 17

Spring Boot : 3.5.6

Hibernate : 6.x

PostgreSQL : 14

Liquibase : YAML

üìö Sources officielles

PostgreSQL ‚Äì JSON_AGG
https://www.postgresql.org/docs/14/functions-aggregate.html

PostgreSQL ‚Äì CREATE VIEW
https://www.postgresql.org/docs/14/sql-createview.html

Hibernate 6 ‚Äì JSON Mapping
https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#json

üß† Conclusion finale (sans d√©tour)

‚úîÔ∏è Oui, OneToMany = LISTE dans la VIEW

‚úîÔ∏è JSON_AGG est la SEULE bonne solution

‚úîÔ∏è List<String> ou List<Objet> ‚Üí les deux sont support√©s

‚úîÔ∏è Tu gardes findById

‚úîÔ∏è Tu √©limines d√©finitivement les probl√®mes de performance JPA
