Je rÃ©Ã©cris lâ€™exemple COMPLET, strictement identique fonctionnellement, mais en ajoutant explicitement TOUS les index nÃ©cessaires, avec :

ğŸ“Œ justification de chaque index

ğŸ“Œ version SQL

ğŸ“Œ version Liquibase YAML

ğŸ“Œ aucun changement cÃ´tÃ© service/repository (bonne pratique)

Toujours basÃ© sur :
Spring Boot 3.5.6 Â· JDK 17 Â· PostgreSQL 14 Â· Liquibase YAML Â· VIEW classique

ğŸ§  Rappel clÃ© (important)

â— Une VIEW PostgreSQL nâ€™a pas dâ€™index

ğŸ‘‰ Les index sont crÃ©Ã©s UNIQUEMENT sur les tables sources

ğŸ‘‰ PostgreSQL les utilise automatiquement lors des requÃªtes sur la VIEW

1ï¸âƒ£ SCHÃ‰MA SQL (TABLES) â€” inchangÃ©
CREATE TABLE user_account (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(100),
    email VARCHAR(150)
);

CREATE TABLE user_profile (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT UNIQUE,
    first_name VARCHAR(100),
    last_name VARCHAR(100)
);

CREATE TABLE user_address (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT,
    street VARCHAR(200),
    city VARCHAR(100)
);

CREATE TABLE tag (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE address_tag (
    address_id BIGINT,
    tag_id BIGINT
);

CREATE TABLE company (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE user_company (
    user_id BIGINT,
    company_id BIGINT
);

CREATE TABLE role (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE user_role (
    user_id BIGINT,
    role_id BIGINT
);

2ï¸âƒ£ INDEX SQL (ğŸ”¥ PARTIE CRITIQUE ğŸ”¥)
ğŸ“Œ Index sur les relations OneToOne / OneToMany
CREATE INDEX idx_user_profile_user_id
ON user_profile(user_id);

CREATE INDEX idx_user_address_user_id
ON user_address(user_id);

Pourquoi ?

utilisÃ© dans JOIN ... ON p.user_id = u.id

utilisÃ© dans JOIN ... ON a.user_id = u.id

Ã©vite Seq Scan

ğŸ“Œ Index sur le ManyToMany Address â†” Tag
CREATE INDEX idx_address_tag_address_id
ON address_tag(address_id);

CREATE INDEX idx_address_tag_tag_id
ON address_tag(tag_id);

Pourquoi ?

utilisÃ© dans la sous-requÃªte agrÃ©gÃ©e

indispensable pour JSON_AGG(tags)

ğŸ“Œ Index sur ManyToMany User â†” Company
CREATE INDEX idx_user_company_user_id
ON user_company(user_id);

CREATE INDEX idx_user_company_company_id
ON user_company(company_id);

ğŸ“Œ Index sur ManyToMany User â†” Role
CREATE INDEX idx_user_role_user_id
ON user_role(user_id);

CREATE INDEX idx_user_role_role_id
ON user_role(role_id);

ğŸ“Œ RÃ©sumÃ© des index (vision globale)
Table	Colonne	Raison
user_profile	user_id	JOIN 1â€“1
user_address	user_id	JOIN 1â€“N
address_tag	address_id	sous-requÃªte
address_tag	tag_id	sous-requÃªte
user_company	user_id	Nâ€“N
user_company	company_id	Nâ€“N
user_role	user_id	Nâ€“N
user_role	role_id	Nâ€“N

ğŸ‘‰ AUCUN index inutile

3ï¸âƒ£ VIEW POSTGRESQL (INCHANGÃ‰E)

âš ï¸ AUCUNE rÃ©fÃ©rence aux index ici (normal)

CREATE VIEW v_user_account_full AS
SELECT
    u.id,
    u.username,
    u.email,
    p.first_name,
    p.last_name,

    addr.addresses,

    JSON_AGG(DISTINCT c.name)
        FILTER (WHERE c.name IS NOT NULL) AS companies,

    JSON_AGG(DISTINCT r.name)
        FILTER (WHERE r.name IS NOT NULL) AS roles

FROM user_account u
LEFT JOIN user_profile p ON p.user_id = u.id

LEFT JOIN (
    SELECT
        a.user_id,
        JSON_AGG(
            jsonb_build_object(
                'street', a.street,
                'city', a.city,
                'tags', t.tags
            )
        ) AS addresses
    FROM user_address a
    LEFT JOIN (
        SELECT
            at.address_id,
            JSON_AGG(t.name) AS tags
        FROM address_tag at
        JOIN tag t ON t.id = at.tag_id
        GROUP BY at.address_id
    ) t ON t.address_id = a.id
    GROUP BY a.user_id
) addr ON addr.user_id = u.id

LEFT JOIN user_company uc ON uc.user_id = u.id
LEFT JOIN company c ON c.id = uc.company_id

LEFT JOIN user_role ur ON ur.user_id = u.id
LEFT JOIN role r ON r.id = ur.role_id

GROUP BY
    u.id, u.username, u.email,
    p.first_name, p.last_name,
    addr.addresses;

4ï¸âƒ£ LIQUIBASE YAML (TABLES + INDEX + VIEW)
db.changelog-master.yaml
databaseChangeLog:
  - include:
      file: db/changelog/001-schema.yaml
  - include:
      file: db/changelog/002-indexes.yaml
  - include:
      file: db/changelog/003-view.yaml

002-indexes.yaml (ğŸ”¥ ESSENTIEL ğŸ”¥)
databaseChangeLog:
  - changeSet:
      id: create-indexes
      author: hamdi
      changes:
        - createIndex:
            tableName: user_profile
            indexName: idx_user_profile_user_id
            columns:
              - column:
                  name: user_id

        - createIndex:
            tableName: user_address
            indexName: idx_user_address_user_id
            columns:
              - column:
                  name: user_id

        - createIndex:
            tableName: address_tag
            indexName: idx_address_tag_address_id
            columns:
              - column:
                  name: address_id

        - createIndex:
            tableName: address_tag
            indexName: idx_address_tag_tag_id
            columns:
              - column:
                  name: tag_id

        - createIndex:
            tableName: user_company
            indexName: idx_user_company_user_id
            columns:
              - column:
                  name: user_id

        - createIndex:
            tableName: user_company
            indexName: idx_user_company_company_id
            columns:
              - column:
                  name: company_id

        - createIndex:
            tableName: user_role
            indexName: idx_user_role_user_id
            columns:
              - column:
                  name: user_id

        - createIndex:
            tableName: user_role
            indexName: idx_user_role_role_id
            columns:
              - column:
                  name: role_id

5ï¸âƒ£ ENTITÃ‰ VIEW JPA (INCHANGÃ‰E)
@Entity
@Table(name = "v_user_account_full")
@Immutable
public class UserAccountView {

    @Id
    private Long id;

    private String username;
    private String email;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private List<AddressView> addresses;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private List<String> companies;

    @JdbcTypeCode(SqlTypes.JSON)
    @Column(columnDefinition = "jsonb")
    private List<String> roles;
}

6ï¸âƒ£ SERVICE (INCHANGÃ‰ â€“ BONNE PRATIQUE)
@Service
@Transactional(readOnly = true)
public class UserAccountQueryService {

    private final UserAccountViewRepository repository;

    public UserAccountQueryService(UserAccountViewRepository repository) {
        this.repository = repository;
    }

    public UserAccountView getById(Long id) {
        return repository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));
    }
}

7ï¸âƒ£ VALIDATION OBLIGATOIRE (Ã  faire)
EXPLAIN ANALYZE
SELECT *
FROM v_user_account_full
WHERE id = 1;

Tu dois voir :

Index Scan using idx_user_address_user_id

Index Scan using idx_address_tag_address_id

Index Scan using idx_user_company_user_id

Index Scan using idx_user_role_user_id

âœ… CONCLUSION Dâ€™EXPERT

âœ”ï¸ Les index sont INDISPENSABLES

âœ”ï¸ Ils sont totalement transparents pour la VIEW

âœ”ï¸ Sans index â†’ VIEW lente

âœ”ï¸ Avec index â†’ performance stable et prÃ©visible

âœ”ï¸ Tu as maintenant une architecture PostgreSQL + Spring Boot robuste
